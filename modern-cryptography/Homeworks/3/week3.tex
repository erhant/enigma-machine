\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{
    hidelinks=true
}
\usepackage{array}
\usepackage{multirow}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\tiny, columns=fullflexible, language=Python, morekeywords={logical_and, log, exp, dot, sqrt, ones, identity}}
\definecolor{mySucces}{RGB}{40, 167, 69}
\definecolor{myFail}{RGB}{220, 53, 69}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\st}[0]{\text{ s.t. }}
\newcommand{\where}[0]{\text{ where }}
\newcommand{\mand}[0]{\text{ and }}
\newcommand{\msgspc}[0]{\mathcal{M}}
\newcommand{\cphspc}[0]{\mathcal{C}}
\newcommand{\keyspc}[0]{\mathcal{K}}
\newcommand{\advrs}[0]{\mathcal{A}}
\newcommand{\correctans}[0]{\colorbox{mySucces}{CORRECT}}
\newcommand{\falseans}[0]{\colorbox{myFail}{FALSE}}
\newcommand\MyBox[2]{
  \fbox{\lower0.75cm
    \vbox to 1.7cm{\vfil
      \hbox to 1.7cm{\hfil\parbox{1.4cm}{#1\\#2}\hfil}
      \vfil}%
  }%
}
\graphicspath{ {./} }

\begin{document}

\begin{center}
\large\textbf{Homework 3 \\ COMP543 Fall 2020 - Modern Cryptography \\}
\normalsize\textbf{ Erhan Tezcan 0070881 \\ 25.10.2020} \\
\end{center}

\begin{center}
\line(1,0){250}
\end{center}

%
%\begin{enumerate}[label=\alph*]
% \item Explain input, output, and the purpose of each algorithm (Key Generation, Encryption, Decryption). 
% \item What are the key space, the message space, and the ciphertext space?
% \item Formally define the   correctness   requirement of an encryption scheme.
% \end{enumerate}
%

\section{Quesitons}
\textbf{Q1:} Formally define a symmetric encryption scheme and its correctness property. Write down the full mathematical details.

\textbf{A1:} A symmetric encryption scheme $\Pi$ is defined as a 3-tuple: $\Pi = (Gen, Enc, Dec)$ and a message space $\msgspc$. There is also a key space $\keyspc$ and ciphertext space $\cphspc$, but these are defined by the $Enc : \msgspc \times \keyspc \xrightarrow{} \cphspc $ and $Gen : \{0, 1\}^\lambda \xrightarrow{} \keyspc$ themselves. 

A symmetric ecryption scheme is defined to have the correctness property if $\forall m \in \msgspc \mand \forall k \in \keyspc$:
$$
Dec(k, Enc(k, m)) = m
$$
Note here that, the sender is running $Enc$ with key $k$, and the receiver runs $Dec$ with the same key $k$. This is why the scheme is known as ``symmetric'', as the key is present at both sides prior to the actual communication.

\vspace{20px}
\textbf{Q2:} Can the decryption algorithm be randomized? What may happen if it is randomized?

\textbf{A2:} A decryption algorithm can not be randomized. Recall that by definition, a randomized algorithm outputs random values on the same input every time. However, this would break correctness: $Dec(k, Enc(k, m)) = m$, since this would not always output $m$, and even if it did then we would not call it a randomized algorithm.

\vspace{20px}
\textbf{Q3:} What is deterministic encryption? Give examples.

\textbf{A3:} Deterministic encryption is when the function $Enc(k, m)$ always outputs the same ciphertext $c$ for the same $(k,m)$ pairs. Several examples are:
\begin{itemize}
	\item \textit{One-Time Pad} uses the function $Enc(k,m) = k \oplus m$ where $\oplus$ is the bitwise XOR operation.
	\item \textit{Shift Ciphers} use a function in the form of $Enc(k, m) = (k + m) \bmod{} n$ where $n$ is the alphabet size, and this function applies to the characters of plaintext. For example a \textit{Caesar Cipher} uses $k=3$ and $n=26$.
\end{itemize}

\vspace{20px}
\textbf{Q4:} Why are deterministic encryption schemes insecure for multiple messages?

\textbf{A4:} This question is actually a bit fallacious, I think what is meant is when a key is re-used for multiple messages. Because otherwise, One-Time Pad supports multiple messages (in the assumption of one key per message) and it is a deterministic encryption scheme, and OTP is a perfectly secure scheme. So my answer will be with respect to key re-use on multiple messages.

For a scheme $\Pi=(Gen,Enc,Dec)$, fix a key $k$ and messages $m, m'$. You have $c=Enc(k,m) \mand c'=Enc(k,m')$. Suppose that there is a perfectly secret encryption scheme $\Pi' = (Gen, Enc, Dec)$ with message space $\msgspc' = \msgspc \setminus \{m, m'\}$ and key space $\keyspc' = \keyspc \setminus \{k\}$. By definition, $|\keyspc'|\geq|\msgspc'|$. By Shannon's Theorem, if there is one cyphertext per message, then $|\msgspc'|=|\cphspc'|=|\keyspc'|$. Since $|\keyspc|=|\keyspc'|+1$ and $|\msgspc|=|\msgspc'|+2$, we clearly see that $\Pi$ breaks perfect secrecy requirement (as stated in Theorem 2.10 in KL Book).

\vspace{20px}
\textbf{Q5:} Formally define semantic security of a symmetric encryption scheme. Write down the full mathematical details.

\textbf{A5:} Semantic security is an interpretation of security, that is equivalent to indistinguishability. Following definition 3.12 from the KL Book, a symmetric encryption scheme $(Enc,Dec)$ is semantically secure against an eavesdropper (an adversary that is doing a ciphertext-only attack) if for every PPT algorithm $\advrs$, there exists a PPT algorithm $\advrs'$ such that for any PPT algorithm \code{Samp} and polynomial time computable functions $f$ and $h$, the following is negligible:
$$
|Pr[\advrs(1^n, Enc(k,m),h(m))=f(m))]-Pr[\advrs'(1^n,|m|,h(m))=f(m)]|
$$
where the first probability is taken over uniform $k \in \{0,1\}^n$, $m$ output by \code{Samp}$(1^n)$, the randomness of $\advrs$ and $Enc$, and the second probability is taken over $m$ output by \code{Samp}$(1^n)$ and the randomness of $\advrs'$.

Here, what is described in layman terms is that in the presence of two adversaries $\advrs$ and $\advrs'$, the probability that one ``knows'' more than other, given that one knows the ciphertext and the other knows the message length, is negligible. It makes perfect sense!


\vspace{20px}
\textbf{Q6:} Formally define semantic security using the indistinguishability definition. Write down the full mathematical details. 

\textbf{A6:} Theorem 3.13 from KL Book already states this. Assuming that an encryption scheme has indistinguishable encryptions in the presence of an eavesdropper, then for any PPT algorithm $\advrs$ there is a PPT algorithm $\advrs$ such that for any $S \subseteq \{0,1\}^l$ and any function $f : \{0,1\}^l \xrightarrow{} \{0,1\}$, there is a negligible function \code{negl} such that:
$$
|Pr[\advrs(1^n, Enc(k,m))=f(m)] - Pr[\advrs'(1^n)=f(m)]| \leq negl(n)
$$
where the first probability is taken over uniform choice of $k \in \{0,1\}^n$ and $m \in S$, the randomness of $\advrs$ and $Enc$, and the second probability is taken over uniform choice of $m \in S$ and the randomness of $\advrs'$. From the semantic security definition (as defined in definition 3.12 from KL Book) if you remove $h(m)$ which is the apriori knowledge, and also remove $|m|$ from the parameter because the scheme is a fixed-length symmetric encryption scheme, then you get the formula above. Also note that in that definition we required the expression to be negligible, but here we say less than equal to negligible. This makes no difference whatsoever, because anything less than equal to a negligible is also negligible.

\vspace{20px}
\textbf{Q7:} Prove that the symmetric encryption scheme $\Pi$ would not be indistinguishable in the presence of an eavesdropper if the adversary (I think we meant ``challenger'' here) can encrypt arbitrary  length messages and the adversary is not restricted to output equal length messages in experiment $PrivK_{(A, \Pi)}^{eav}$.

\textbf{A7:} Let us briefly define this specific indistinguishability experiment $\code{PrivK}_{\advrs, \Pi}^{\code{eav}}(n)$:
\begin{enumerate}
\item Adversary $\advrs$ is given input $1^n$, and outputs a pair of messages $m_0, m_1$ with \textbf{arbitrary lengths}.
\item A key $k$ is generated and a uniform bit $b$ is chosen. $c \xleftarrow{} Enc(k,m_b)$ is computed and given to $\advrs$. 
\item $\advrs$ outputs a bit $b'$.
\item If $b=b'$ then the experiment results with 1, 0 otherwise. If the result is 1, $\advrs$ succeds in distinguishing these messages.
\end{enumerate}
The difference of this experiment to what we have seen in the book is that now the messages can be of different arbitrary lengths. Since this question asks us to delve in to the indistinguishability, I am assuming that correctness is not broken. Also considering that the adversary would easily distinguish the message from the length of ciphertext if they were equal (which adversary would infer from the implementation of $Enc$, which it has access to), so let us assume that $|c|=max(|m_0|,|m_1|)$. Since the lengths are different, adversary knows that shorter message could normally have another ciphertext of the same length, if it were to be the longest of the two messages, however here it had to be padded. The padding is done by $Enc$, which the adversary would know exactly how it happens. An example would be to choose uniform $m_0 = 0$ and $m_1 \in \{0, 1\}^{p(n)}$ for some polynomial $p(n)$. What we have is that:
$$
Pr[\code{PrivK}_{\advrs, \Pi}^{\code{eav}}(n)=1] = 1 - Pr[Enc_{padded}(k,m_0)=Enc(k,m_1)]
$$
which is non-negligible, thereby showing that $\advrs$ wins the game with non-negligible probability.



\end{document}