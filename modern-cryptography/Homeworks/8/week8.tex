\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{centernot}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{array}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{algorithm}
\usepackage{cite}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\tiny, columns=fullflexible, language=Python, morekeywords={logical_and, log, exp, dot, sqrt, ones, identity}}
\definecolor{mySucces}{RGB}{40, 167, 69}
\definecolor{myFail}{RGB}{220, 53, 69}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\st}[0]{\text{ s.t. }}
\newcommand{\where}[0]{\text{ where }}
\newcommand{\mand}[0]{\text{ and }}
\newcommand{\msgspc}[0]{\mathcal{M}}
\newcommand{\cphspc}[0]{\mathcal{C}}
\newcommand{\keyspc}[0]{\mathcal{K}}
\newcommand{\advrs}[0]{\mathcal{A}}
\newcommand{\distin}[0]{\mathcal{D}}
\newcommand{\oracle}[0]{\mathcal{O}}
\newcommand{\correctans}[0]{\colorbox{mySucces}{CORRECT}}
\newcommand{\falseans}[0]{\colorbox{myFail}{FALSE}}
\newcommand\MyBox[2]{
  \fbox{\lower0.75cm
    \vbox to 1.7cm{\vfil
      \hbox to 1.7cm{\hfil\parbox{1.4cm}{#1\\#2}\hfil}
      \vfil}%
  }%
}
\graphicspath{ {./} }
\newtheorem{theorem}{Theorem}[section]
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}    

\begin{document}

\begin{center}
\large\textbf{Homework 8 \\ COMP543 Fall 2020 - Modern Cryptography \\}
\normalsize\textbf{ Erhan Tezcan 0070881 \\ 25.11.2020} \\
\end{center}

\begin{center}
\line(1,0){250}
\end{center}

%
%\begin{enumerate}[label=\alph*.]
% \item Explain input, output, and the purpose of each algorithm (Key Generation, Encryption, Decryption). 
% \item What are the key space, the message space, and the ciphertext space?
% \item Formally define the   correctness   requirement of an encryption scheme.
% \end{enumerate}
%

%
%\begin{algorithm}
%\caption{\code{DivideRounds} for a new event \code{x}}
%\label{alg:round}
%\begin{algorithmic}
%\STATE $r \gets \text{max}(selfParent.Round, otherParent.Round)$
%\IF {$x \text{ strongly sees } > \frac{2n}{3} \text{ round } r \text{ witnesses}$} 
%        \STATE $x.Round \gets r+1$
%\ELSE
%        \STATE $x.Round \gets r$
%\ENDIF 
%\STATE $x.witness \gets x.Round > x.selfParent.Round$
%\end{algorithmic}
%\end{algorithm}
%
\section{Quesitons}
\textbf{Q1:} Let $p,N$ be integers with $p|N$. Prove that for any integer $x$, $[[x \bmod N] \bmod p]$ = $[x \bmod p]$. Show that, in contrast, $[[x \bmod p] \bmod N]$ need not equal $[x \bmod N]$.

\textbf{A1:} If $p | N$ then $p \leq N$ and $\mathbb{Z}_p \subseteq \mathbb{Z}_N$. We can suppose that $x$ is positive without loss of generality. For a positive $x$ with respect to $N$ and $p$ there are 3 cases:
\begin{itemize}
	\item $0 \leq x < p$, then $x \in \mathbb{Z}_p$ and so $[x \bmod N]=[x \bmod p]$, then $[[x \bmod N] \bmod p]$ = $[x \bmod p]$ is true.
	\item $p \leq x < N$ then $\exists x' \in  \mathbb{Z}_N$ s.t. $x = pk + x'$ for some $k \in \mathbb{N}$. If $x' \in  \mathbb{Z}_N$ and $x' > p$ then $\exists x'' \in \mathbb{Z}_p$ s.t. $x' = pk' + x''$ for some $k' \in \mathbb{N}$. If $x'=p$ then $x''=0$ and $k':=k'+1$ instead. If $x'<p$ then $x''=x'$ where $x'' \in \mathbb{Z}_p$ and $k':=0$. As a result,  $x = pk + pk' + x'' = p(k+k') + x''$. 
	\item $N \leq x$  then $\exists x' \in  \mathbb{Z}_N$ s.t. $x = Nk + x'$ for some $k \in \mathbb{N}$.  Since $p | N$ we can say $\exists k_p \in \mathbb{N}$ where $N=pk_p$. By following a similar logic to what we did above, $x = Nk + pk' + x''$.. So, $x = pk_pk + pk' + x'' = p(k_pk+k') + x''$.
\end{itemize}
As the 3 cases demonstrate, the claim $[[x \bmod N] \bmod p]$ = $[x \bmod p]$ is true, both sides eventually reduce to $x''$.

 However, it is not always true that $[[x \bmod p] \bmod N] = [x \bmod N]$. We can prove this just by giving a counter-example. Take any $p$, $N = pk$ for some $k \in \mathbb{N}$ and $x=pk+r$ where $p < r < N$. Then $[x \bmod N]=r > p$, but on the left hand-side since we do $[x \bmod p]$ first, nothing after that will never be equal to $r$ as $r \not\in \mathbb{Z}_p$.

\newpage
\textbf{Q2:} \footnote{``Intractable Problems'' segment of Dan Boneh's Coursera course discusses this. Also see KL Book ed.2 section 8.4.2} Let $\rho$ be a polynomial-time algorithm that, on input $1^n$, outputs a (description of a) cyclic group $G$, its order $q$ (with $||q||=n$), and a generator $g$.
If the discrete-logarithm problem is hard relative to $\rho$, then prove that the following hash function family $(Gen, H)$ is a fixed-length collision-resistant hash function family.
\begin{itemize}
	\item $Gen$: on input $1^n$, run $\rho(1^n)$ to obtain $(G,q,g)$, and then select $h\gets G$. Output $s:=\langle G,q,g,h\rangle$ as the key.
	\item $H$: given a key $s=\langle G,q,g,h \rangle$ and input $(x_1, x_2) \in Z_q \times Z_q$, output $H^s(x_1, x_2) := g^{x_1} \times h^{x_2} \in G$.
\end{itemize}
    
\textbf{A2:} I am following a proof similar to what is shown in section 8.4.2. of KL Book $2^\textrm{nd}$ edition. To prove that if discrete-logarithm problem is hard relative to $\rho$ then the hash function family $(Gen, H)$ is secure, we take the contrapositive and assume that there exists an algorithm $\advrs$ than can break the hash function family, and construct an algorithm $B$ that easily solves the discrete-logarithm problem. We see our constructed game in algorithm \ref{alg:q2}: for a security parameter $n$, \code{Chal} and $B$ plays discrete-logarithm game, $B$ and $\advrs$ plays hash-collision game. $\advrs$ breaks the hash-collision with probability $\epsilon(n)$.
\begin{algorithm}
\caption{The mixed game.}
\label{alg:q2}
\begin{algorithmic}
\STATE \code{Chal} runs $\rho(n)$ and obtains $(G,q,g)$.
\STATE $h \gets G$.
\STATE $(G,q,g,h)$ is given to $B$.
\STATE At $B$, $s = \langle G,q,g,h \rangle$ is constructed.
\STATE $B$ gives $s$ to $\advrs$.
\STATE $\advrs$ returns $x, x'$ to $B$.
\IF{$x \ne x'$ and $H^s(x) = H^s(x')$}
	\IF{$h = 1$}
		\STATE Return 0.
	\ELSE
		\STATE Parse $x$ as $(x_1, x_2)$ and $x'$ as $(x_1', x_2')$ where $x_1, x_2, x_1', x_2' \in \mathbb{Z}_q$.
		\STATE Return $[(x_1 - x_1')(x_2 - x_2')^{-1} \bmod q]$.
	\ENDIF
\ELSE
	\STATE Return 0.
\ENDIF
\end{algorithmic}
\end{algorithm}

What does it mean to have $H^s(x_1, x_2) = H^s(x_1', x_2')$? It means:
$$
H^s(x_1, x_2) = g^{x_1}h^{x_2} = g^{x_1'}h^{x_2'} = H^s(x_1', x_2')
$$
Now if $g^{x_1}h^{x_2} = g^{x_1'}h^{x_2'}$ we can't have $x_1 = x_1'$  in $\mathbb{Z}_q$ because that would imply $x_2 = x_2'$  in $\mathbb{Z}_q$ and then inadvertnetly $x = x'$, which is not a collision. So indeed $x_2 \ne x_2'$ in $\mathbb{Z}_q$ and $x_1 \ne x_1'$  in $\mathbb{Z}_q$. Leaving $g$'s and $h$'s alone we get:
$$
g^{x_1}g^{-x_1'} = h^{x_2'}h^{-x_2}
$$
Since $q$ is a prime order, the inverse $[(x_2' - x_2)^{-1} \bmod q]$ exists. Show this inverse as $i_2$ (2 to indicate $x_2$ and $x_2'$).  If we raise the expression above to this power:
$$
g^{(x_1-x_1')\times i_2} = h^{(x_2'-x_2)\times i_2} = h^1 = h
$$
We see that $g^{(x_1-x_1')^{i_2}} = h$, which solves the discrete logarithm of $log_gh$ to be $[(x_1-x_1')\times i_2 \bmod q] = [(x_1 - x_1')(x_2 - x_2')^{-1} \bmod q]$, which is what our algorithm returned. This tells us that if $\advrs$ find a collision with $\epsilon(n)$ probability then $B$ solves discrete-logarithm with $\epsilon(n)$ probability. Since we assumed it is hard to break the discrete-logarithm probability, this $\epsilon(n)$ must be negligible, therefore the hash function is secure!
\end{document}