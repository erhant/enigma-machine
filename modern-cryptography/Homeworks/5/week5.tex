\documentclass[12pt,reqno]{amsart}

\usepackage{amsthm,amsmath,amssymb}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{centernot}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{courier}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{
    hidelinks=true
}
\usepackage{array}
\usepackage{multirow}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\tiny, columns=fullflexible, language=Python, morekeywords={logical_and, log, exp, dot, sqrt, ones, identity}}
\definecolor{mySucces}{RGB}{40, 167, 69}
\definecolor{myFail}{RGB}{220, 53, 69}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\st}[0]{\text{ s.t. }}
\newcommand{\where}[0]{\text{ where }}
\newcommand{\mand}[0]{\text{ and }}
\newcommand{\msgspc}[0]{\mathcal{M}}
\newcommand{\cphspc}[0]{\mathcal{C}}
\newcommand{\keyspc}[0]{\mathcal{K}}
\newcommand{\advrs}[0]{\mathcal{A}}
\newcommand{\oracle}[0]{\mathcal{O}}
\newcommand{\correctans}[0]{\colorbox{mySucces}{CORRECT}}
\newcommand{\falseans}[0]{\colorbox{myFail}{FALSE}}
\newcommand\MyBox[2]{
  \fbox{\lower0.75cm
    \vbox to 1.7cm{\vfil
      \hbox to 1.7cm{\hfil\parbox{1.4cm}{#1\\#2}\hfil}
      \vfil}%
  }%
}
\graphicspath{ {./} }
\newtheorem{theorem}{Theorem}[section]
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}    

\begin{document}

\begin{center}
\large\textbf{Homework 5 \\ COMP543 Fall 2020 - Modern Cryptography \\}
\normalsize\textbf{ Erhan Tezcan 0070881 \\ 08.11.2020} \\
\end{center}

\begin{center}
\line(1,0){250}
\end{center}

%
%\begin{enumerate}[label=\alph*]
% \item Explain input, output, and the purpose of each algorithm (Key Generation, Encryption, Decryption). 
% \item What are the key space, the message space, and the ciphertext space?
% \item Formally define the   correctness   requirement of an encryption scheme.
% \end{enumerate}
%

\section{Quesitons}
\textbf{Q1:} What is the security guarantee provided by the MAC schemes? Compare and contrast with that of encryption schemes.

\textbf{A1:} The threat model of MAC is ``Adaptive Chosen-Message Attack'', where we assume the attacker can induce the sender to authenticate messages of attacker's choice. The security goal is ``Existential Unforgeability'', where we want the attacker to be unable to forge a valid tag on any message not authenticated by the sender. So here, we care about the ownership and authentication of the message being sent, rather than it's security. In fact, MAC is related to integrity, where other encryption schemes we have seen so far have been about security. These are orthogonal concerns!


\vspace{20px}
\textbf{Q2:} Compare MAC schemes with other integrity detection or protection methods, such as error-detection codes, error-correction codes, erasure codes, CRC checksums. How are the usage scenarios different? What type of guarantee does each one provide?

\textbf{A2:} Error-detection codes, error-correction codes, erasure codes and CRC checksums all are designed to prevent or recover from random errors that occur during transmission. However, in the case of MAC, what would be perceived as ``error'' is not actually a random error, but in fact it is the result of an adversary tampering with the message! So, MAC is harder, as the latter methods are designed against random errors, while MAC is designed against an efficient adversary that can do whatever it wants!

\vspace{20px}
\textbf{Q3:} List at least three scenarios where confidentiality alone, without integrity, is not enough of a security measure.

\textbf{A3:} An active attacker can tamper with the data and look at the result, without even actually looking at what is being sent. Several examples are: Replay attacks, unauthenticated messages, or even messages that are thought to be geniune but are actually tampered with.

\vspace{20px}
\textbf{Q4:} Formally define a MAC scheme and write down full security definition (existential unforgeability under adaptive chosen message attack). Why does this definition not provide a VerifyMac oracle to the adversary?

\textbf{A4:} Let us define the $\code{Mac-Forge}_{\advrs, \Pi}(n)$ game:
\begin{enumerate}
	\item Challenger send $1^n$ to the adversary.
	\item Challenger chooses a key $k \xleftarrow{R} K$.
	\item Adversary can make $\code{poly}(n)$ queries to a $Mac$ oracle, which returns the tag of a message of adversaries choice.
	\item Then the adversary makes an existential forgery attack, by sending a message and a tag $(m, t)$, such that this pair was not obtained from the oracle accesses before.
	\item The challenger looks at $(m, t)$, and if $Vrfy_k(m,t)=1$ then it outputs 1, which means the adversary wins. Otherwise, it outputs 0.
\end{enumerate}
Existential unforgeability under adaptive chosen message attack is when for all PPT adversaries there exists a negligibly function $\code{negl}$ such that:
$$
Pr[\code{Mac-Forge}_{\advrs, \Pi}(n) = 1] \leq \code{negl}(n)
$$
The adversary is not given oracle access for $Vrfy$ because if it had one, it could just create any message and get it's tag, then submit it, which would be correct.

\vspace{20px}
\textbf{Q5:} Let $F$ be a pseudorandom function. Show that the following MAC for messages of length $2n$ is insecure: Gen outputs a uniform $k \in \{0, 1\}^n$, and to authenticate a message $m_1 || m_2$ with $|m_1|=|m_2|=n$, compute the tag $F_k(m_1) || F_k(F_k(m_2))$

\textbf{A5:} Quite simply, we will do 2 queries only and win the game with advantage 1. Let $m_z \xleftarrow{} \{0,1\}^n$.
\begin{enumerate}
	\item Query $Mac_k$ with $m_a || m_z$, which yields the tag $t_{az} = F_k(m_a) || F_k(F_k(m_z))$
	\item Query $Mac_k$ with $m_z || m_b$, which yields the tag $t_{zb} = F_k(m_z) || F_k(F_k(m_b))$
	\item We can know use either $(m, t)$ pairs below:
	\begin{itemize}
		\item $m = m_z || m_z$ and $t = t_{zb}[0] || t_{az}[1]$
		\item $m = m_a || m_b$ and $t = t_{az}[0] || t_{zb}[1]$
	\end{itemize}
\end{enumerate}
Both will be accepted and verified  by the challenger!

\vspace{20px}
\textbf{Q6:} Why does one need two different keys for the underlying PRF in the CBC-MAC and NMAC constructions? What happens if one does not perform the step with the second key?

\textbf{A6:} If you query $m$ and obtain $t$, then query with $t$ and obtain $t'$, you can break the scheme with message $\langle m || t\rangle$ and the tag $t'$.

\vspace{20px}
\textbf{Q7:} How can one use a single key, instead of multiple keys required in the constructions presented? Essentially, you need to think about ways to convert a single key to multiple keys, in a secure manner. Note that there are multiple ways of achieving this. Try to write down at least two-three different methods.

\textbf{A7:} A single key can be used to generate a number of keys, an example would be to use a keyed PRF for this, as in: $k$ is the single key, and other keys $k_i$ are obtained with $F_k(i)$. You can also use PRG for this.

\vspace{20px}
\textbf{Q8:} What does it mean for a security bound to be tight? How would you show that some bound is tight?

\textbf{A8:} It means that when a scheme is used for a certain number of messages with a single key, it becomes insecure and the key must be refreshed. This makes the bound a tight one. An example is to say that $Pr[\advrs \text{ wins}]$ is tightly bounded by $1/2^\lambda$ instead of $Pr[\advrs \text{ wins}] < negl(\lambda)$.

\vspace{20px}
\textbf{Q9:} Compare CPA and CCA security definitions.

\textbf{A9:} In CCA, in addition to CPA, the adversary has the ability to decrypt ciphertexts of it's choice. In the experiment, this is obtained by giving the adversary the access to a decryption oracle. Other than that, the experiments are same.

\vspace{20px}
\textbf{Q10:} How can one obtain authenticated encryption (and CCA-security) using encryption schemes and MAC schemes together? Which methods are proven secure, which are not?

\textbf{A10:} There are three ways to do this:
\begin{itemize}
\item \textbf{encrypt-and-authenticate}: To send a message $m$, you calculate both $c \xleftarrow{} Enc_{k_E}(m) \mand t \xleftarrow{} Mac_{k_M}(m)$ and send $\langle c, t \rangle$. This is so not secure, that it is actually vulnerable to an eavesdropping (ct-only) attack.
\item \textbf{authenticate-then-encrypt}: To send a message $m$, you first calculate $t \xleftarrow{} Mac_{k_M}(m)$ and then calculate $c \xleftarrow{} Enc_{k_E}(m || t)$, finally you send just the $c$. This method is  not completely secure, however, if used with rand-CTR mode or rand-CBC, this actually provides authenticated encryption.
\item \textbf{encrypt-then-authenticate}: To send a message $m$, you first calculate  $c \xleftarrow{} Enc_{k_E}(m)$ and then calculate $t \xleftarrow{} Mac_{k_M}(c)$, finally you send $\langle c, t \rangle$. This method is proven to be an authenticated encryption, always.
\end{itemize}

\vspace{20px}
\textbf{Q11:} Formally define collision resistance for a hash function family. 

\textbf{A11:} Given a hash function $H : X \xrightarrow{} Y$, no efficient adversary should be able to find an $x \in X$ and $x' \in X$, such that $H(x')=H(x) \mand x' \ne x$.

\vspace{20px}
\textbf{Q12:} Write down a full reduction proof for the collision resistance of the Merkle-Damgard scheme, assuming that the underlying hash function is collision resistant. You may be asked to volunteer to perform the proof in class.

\textbf{A12:} Let us call the underlying hash function $h$, and the full function as $H$. 
\begin{theorem} 
If $h$ is a collision resistant hash function, then $H$ is a collision resistant hash function.
\end{theorem}
\begin{proof}
Suppose $H(m) = H(m')$. We will build a collision for $h$. (Contra-positive of the theorem). Let us first assign names to the chaining variables for both hashes:
\begin{itemize}
	\item $IV = H_0, H_1, \ldots, H_t , H_{t+1} = H(m)$	
	\item $IV = H_0', H_1', \ldots, H_t' , H_{t+1}' = H(m')$
\end{itemize}
Notice how if $H(m)=H(m')$ then $H_{t+1}=H_{t+1}'$. This would mean:
$$
h(H_t, m_t || PB) = H_{t+1} = H_{t+1}' = h(H_t', m_t' || PB')
$$
Now thanks to the equality we have a candidate collision for $h$, it is:
$$
h(H_t, m_t || PB) = h(H_t', m_t' || PB')
$$
Note that a collision is when the inputs are different! So if $H_t \ne H_t'$ or $m_t \ne m_t'$ or $PB \ne PB'$ then there is infact a collision.

Suppose that $H_t = H_t'$ and $m_t = m_t'$ and $PB = PB'$. Then this gives us the equality:
$$
h(H_{t-1}, m_{t-1}) = H_t = H_t' = h(H_{t-1}', m_{t-1}')
$$
which tells in short:
$$
h(H_{t-1}, m_{t-1}) = h(H_{t-1}', m_{t-1}')
$$
So if $H_{t-1} \ne H_{t-1}'$ or $m_{t-1} \ne m_{t-1}'$ then there is collision. 

Suppose that $H_{t-1}=H_{t-1}'$ and $m_{t-1}=m_{t-1}'$. Notice how this is like repeating what we did above, one by one from the end of the message to the beginning! Eventually we iterate to the beginning of the messages, and we are left with the two options:
\begin{enumerate}
	\item Find collision for $h$,
	\item $\forall i: m_i=m_i' \implies M = M'$
\end{enumerate}
The second option means that the messages are infact the same, so this wouldn't be a collision. The first one says that there must be a collision in $h$ for there to be a collision on $H$. Our theorem stated that if $h$ is collision resistant then $H$ is collision resistant, and this proves it.
\end{proof}

\vspace{20px}
\textbf{Q13:} Formally define second preimage resistance for a hash function family.

\textbf{A13:} Given a hash function $H : X \xrightarrow{} Y$ and an element $x \in X$, no efficient adversary should be able to find an $x' \in X$ such that $H(x')=H(x) \mand x' \ne x$.

\vspace{20px}
\textbf{Q14:} Formally define preimage resistance for a hash function family.

\textbf{A14:} Given a hash function $H : X \xrightarrow{} Y$ and an element $y \in Y$, no efficient adversary should be able to find an $x \in X$ such that $H(x)=y$.

\end{document}